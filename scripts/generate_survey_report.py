#!/usr/bin/env python3
"""
Generate PDF report from survey findings.

Reads findings.jsonl and generates a formatted report with:
- Dynamic stats from database
- Grouped findings by category
- Survey figures
- Proper text wrapping
- Table of contents
- Smart page breaks
"""

import json
import os
import re
import sys
from pathlib import Path
from datetime import datetime
from collections import defaultdict

sys.path.insert(0, str(Path(__file__).parent.parent))

from fpdf import FPDF
from sharur.operators import Sharur

# Configuration
DB_PATH = "data/altiarchaeota_production/sharur.duckdb"
SURVEY_DIR = Path("data/altiarchaeota_production/survey")
OUTPUT_DIR = Path("data/altiarchaeota_production")
FINDINGS_PATH = SURVEY_DIR / "findings.jsonl"
FIGURES_DIR = SURVEY_DIR / "figures"
OUTPUT_PDF = OUTPUT_DIR / "altiarchaeota_survey_report.pdf"


def truncate_genome_id(genome_id, max_len=25):
    """Truncate long genome IDs for display."""
    if not genome_id or len(genome_id) <= max_len:
        return genome_id
    # Keep GCA_ prefix and truncate middle
    if genome_id.startswith("GCA_"):
        return genome_id[:max_len-3] + "..."
    return genome_id[:max_len-3] + "..."


def clean_figure_name(name):
    """Remove numeric prefixes and clean up figure names."""
    # Remove leading numbers like "01_", "10_", etc.
    name = re.sub(r'^\d+[_\s]+', '', name)
    # Replace underscores with spaces and title case
    name = name.replace('_', ' ').title()
    return name


def is_repetitive_finding(finding, seen_titles):
    """Check if a finding is repetitive spam."""
    title = finding.get('title', '')
    # Filter out repetitive "Novel cluster" findings (keep first 3)
    if title.startswith('Novel cluster:') and 'genes on' in title:
        cluster_count = sum(1 for t in seen_titles if t.startswith('Novel cluster:'))
        if cluster_count >= 3:
            return True
    return False


def fix_template_variables(text, evidence):
    """Fix any unsubstituted template variables in text."""
    if not text:
        return text
    # Common template patterns
    patterns = [
        (r'\{total_tpr\}', str(evidence.get('total_tpr_proteins', evidence.get('total_tpr', '451')))),
        (r'\{n_genomes\}', str(evidence.get('n_genomes', '63'))),
        (r'\{n_proteins\}', str(evidence.get('n_proteins', '94656'))),
    ]
    for pattern, replacement in patterns:
        text = re.sub(pattern, replacement, text)
    return text


class SurveyReport(FPDF):
    """PDF report with proper text wrapping and smart layout."""

    def __init__(self):
        super().__init__()
        self.set_auto_page_break(auto=True, margin=20)
        self.set_margins(left=20, top=15, right=20)
        self.toc_entries = []  # Track TOC entries
        self.in_toc = False  # Flag to suppress footer on TOC page

    def header(self):
        if self.page_no() > 1:
            # Subtle header line
            self.set_draw_color(60, 100, 60)
            self.set_line_width(0.3)
            self.line(20, 12, self.w - 20, 12)
            self.set_font('Helvetica', 'I', 8)
            self.set_text_color(100, 100, 100)
            self.cell(0, 8, 'Altiarchaeota Survey Report', 0, 0, 'L')
            self.cell(0, 8, f'Page {self.page_no()}', 0, 0, 'R')
            self.ln(12)
            self.set_text_color(0, 0, 0)

    def footer(self):
        if self.in_toc:
            return  # No footer on TOC page
        self.set_y(-15)
        self.set_draw_color(60, 100, 60)
        self.set_line_width(0.2)
        self.line(20, self.h - 18, self.w - 20, self.h - 18)
        self.set_font('Helvetica', 'I', 7)
        self.set_text_color(120, 120, 120)
        self.cell(0, 10, 'Generated by Sharur', 0, 0, 'C')

    def chapter_title(self, num, title, add_to_toc=True):
        if add_to_toc:
            self.toc_entries.append((num, title, self.page_no()))
        self.set_font('Helvetica', 'B', 16)
        self.set_fill_color(60, 100, 60)
        self.set_text_color(255, 255, 255)
        # Add subtle shadow effect
        self.set_x(self.l_margin + 1)
        self.cell(self.w - self.l_margin - self.r_margin - 1, 12, f'  {num}. {title}', 0, 1, 'L', True)
        self.set_text_color(0, 0, 0)
        self.ln(6)

    def add_toc_entry(self, num, title, page):
        """Add a styled TOC entry with dotted leader."""
        self.set_font('Helvetica', '', 11)
        self.set_text_color(40, 40, 40)
        text = f"{num}. {title}"
        text_width = self.get_string_width(text)
        page_str = str(page)
        page_width = self.get_string_width(page_str)

        # Calculate space for dots
        available = self.w - self.l_margin - self.r_margin - text_width - page_width - 5
        dot_width = self.get_string_width(' . ')
        num_dots = int(available / dot_width)
        dots = ' .' * num_dots

        self.cell(text_width + 2, 7, text, 0, 0, 'L')
        self.set_text_color(180, 180, 180)
        self.cell(available, 7, dots, 0, 0, 'L')
        self.set_text_color(60, 100, 60)
        self.set_font('Helvetica', 'B', 11)
        self.cell(page_width + 3, 7, page_str, 0, 1, 'R')
        self.set_text_color(0, 0, 0)

    def add_evidence_box(self, text):
        """Add evidence in a subtle gray box."""
        self.set_font('Helvetica', 'I', 9)
        self.set_fill_color(245, 250, 245)
        self.set_text_color(50, 70, 50)
        text = self._clean_text(text)
        text = self._wrap_long_words(text, 50)
        w = self.w - self.l_margin - self.r_margin
        self.set_x(self.l_margin)
        # Draw box background
        self.multi_cell(w, 5, f"  {text}", 0, 'L', True)
        self.set_text_color(0, 0, 0)
        self.ln(2)

    def add_markdown_table(self, table_lines):
        """Render a markdown table as a proper PDF table."""
        if not table_lines:
            return

        # Parse header and rows
        rows = []
        for line in table_lines:
            line = line.strip()
            if line.startswith('|') and line.endswith('|'):
                # Skip separator lines (|---|---|)
                if re.match(r'^\|[\s\-:|]+\|$', line):
                    continue
                # Parse cells
                cells = [c.strip() for c in line.split('|')[1:-1]]
                if cells:
                    rows.append(cells)

        if not rows:
            return

        # Calculate column widths
        n_cols = len(rows[0])
        available_width = self.w - self.l_margin - self.r_margin - 4
        col_width = available_width / n_cols

        # Ensure we have space
        self.maybe_add_page(40)

        # Draw table
        self.set_font('Helvetica', '', 9)
        row_height = 6

        for i, row in enumerate(rows):
            # Header row gets different styling
            if i == 0:
                self.set_font('Helvetica', 'B', 9)
                self.set_fill_color(60, 100, 60)
                self.set_text_color(255, 255, 255)
            else:
                self.set_font('Helvetica', '', 9)
                if i % 2 == 0:
                    self.set_fill_color(245, 250, 245)
                else:
                    self.set_fill_color(255, 255, 255)
                self.set_text_color(40, 40, 40)

            self.set_x(self.l_margin + 2)
            for j, cell in enumerate(row):
                cell = self._clean_text(cell)[:30]  # Truncate long cells
                self.cell(col_width, row_height, cell, 1, 0, 'C', True)
            self.ln(row_height)

        self.set_text_color(0, 0, 0)
        self.ln(3)

    def add_separator(self):
        """Add a subtle horizontal separator between findings."""
        self.ln(2)
        self.set_draw_color(220, 230, 220)
        self.set_line_width(0.2)
        y = self.get_y()
        self.line(self.l_margin + 20, y, self.w - self.r_margin - 20, y)
        self.ln(4)

    def section_title(self, title):
        self.set_font('Helvetica', 'B', 12)
        self.set_text_color(60, 100, 60)
        title = self._clean_text(title)[:100]
        w = self.w - self.l_margin - self.r_margin
        self.multi_cell(w, 8, title, align='L')
        self.set_text_color(0, 0, 0)
        self.ln(2)

    def subsection_title(self, title):
        self.set_font('Helvetica', 'B', 10)
        self.set_text_color(70, 110, 70)
        title = self._clean_text(title)[:120]
        w = self.w - self.l_margin - self.r_margin
        self.multi_cell(w, 7, title, align='L')
        self.set_text_color(0, 0, 0)
        self.ln(1)

    def body_text(self, text):
        """Render body text with full markdown support."""
        lines = text.split('\n')
        i = 0
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()

            # Skip empty lines
            if not stripped:
                self.ln(2)
                i += 1
                continue

            # Table detection
            if stripped.startswith('|') and stripped.endswith('|'):
                table_lines = []
                while i < len(lines):
                    l = lines[i].strip()
                    if l.startswith('|') and l.endswith('|'):
                        table_lines.append(l)
                        i += 1
                    else:
                        break
                if table_lines:
                    self.add_markdown_table(table_lines)
                continue

            # H2 header: ## Title
            if stripped.startswith('## '):
                title = stripped[3:].strip()
                title = re.sub(r'\*\*([^*]+)\*\*', r'\1', title)  # Remove bold markers
                self.section_title(title)
                i += 1
                continue

            # H3 header: ### Title
            if stripped.startswith('### '):
                title = stripped[4:].strip()
                title = re.sub(r'\*\*([^*]+)\*\*', r'\1', title)
                self.subsection_title(title)
                i += 1
                continue

            # Bullet point: - text or * text
            if stripped.startswith('- ') or stripped.startswith('* '):
                bullet_text = stripped[2:].strip()
                self._render_markdown_bullet(bullet_text)
                i += 1
                continue

            # Regular paragraph - collect lines until special element
            para_lines = []
            while i < len(lines):
                l = lines[i]
                s = l.strip()
                if not s:
                    i += 1
                    break
                if s.startswith('|') or s.startswith('## ') or s.startswith('### ') or s.startswith('- ') or s.startswith('* '):
                    break
                para_lines.append(l)
                i += 1

            if para_lines:
                para_text = ' '.join(l.strip() for l in para_lines)
                self._render_markdown_text(para_text)

    def _render_markdown_bullet(self, text):
        """Render a bullet point with bold support."""
        self.set_x(self.l_margin + 5)
        self.set_font('Helvetica', '', 10)
        self.cell(5, 5, chr(149), 0, 0)
        self._render_inline_markdown(text, self.w - self.get_x() - self.r_margin)
        self.ln(1)

    def _render_markdown_text(self, text):
        """Render paragraph text with bold support."""
        self.set_font('Helvetica', '', 10)
        self._render_inline_markdown(text, self.w - self.l_margin - self.r_margin)
        self.ln(3)

    def _render_inline_markdown(self, text, width):
        """Render text with inline **bold** markers."""
        text = self._clean_text(text)
        # Split on bold markers
        parts = re.split(r'(\*\*[^*]+\*\*)', text)
        x_start = self.get_x()
        current_x = x_start
        line_height = 5

        for part in parts:
            if not part:
                continue
            # Check if this is a bold section
            if part.startswith('**') and part.endswith('**'):
                content = part[2:-2]
                self.set_font('Helvetica', 'B', 10)
            else:
                content = part
                self.set_font('Helvetica', '', 10)

            # Word wrap within the part
            words = content.split()
            for word in words:
                word_width = self.get_string_width(word + ' ')
                if current_x + word_width > x_start + width:
                    # New line
                    self.ln(line_height)
                    self.set_x(x_start)
                    current_x = x_start
                self.cell(word_width, line_height, word + ' ', 0, 0)
                current_x += word_width

        self.ln(line_height)

    def add_bullet(self, text):
        self.set_font('Helvetica', '', 10)
        text = self._clean_text(text)
        self.set_x(self.l_margin + 5)
        self.cell(5, 5, chr(149), 0, 0)
        w = self.w - self.get_x() - self.r_margin
        self.multi_cell(w, 5, text, align='L')

    def add_numbered_item(self, num, text):
        """Add a numbered list item."""
        self.set_font('Helvetica', '', 10)
        text = self._clean_text(text)
        self.set_x(self.l_margin + 5)
        self.cell(12, 5, f"{num}.", 0, 0)
        w = self.w - self.get_x() - self.r_margin
        self.multi_cell(w, 5, text, align='L')

    def _clean_text(self, text):
        """Clean text for PDF rendering."""
        if not text:
            return ""
        # Truncate genome IDs in text
        text = re.sub(
            r'GCA_\d+_\d+_[A-Za-z0-9_]+genomic',
            lambda m: truncate_genome_id(m.group(0)),
            text
        )
        text = text.encode('latin-1', 'replace').decode('latin-1')
        text = text.replace('\t', '    ')
        return text

    def _wrap_long_words(self, text, max_len=40):
        """Break very long words."""
        words = text.split()
        result = []
        for word in words:
            if len(word) > max_len:
                for i in range(0, len(word), max_len):
                    chunk = word[i:i+max_len]
                    if i + max_len < len(word):
                        chunk += '-'
                    result.append(chunk)
            else:
                result.append(word)
        return ' '.join(result)

    def add_image(self, path, caption="", width=170):
        if os.path.exists(path):
            try:
                self.image(path, x=20, w=width)
                if caption:
                    self.set_font('Helvetica', 'I', 8)
                    self.ln(2)
                    self.multi_cell(width, 4, caption, align='C')
                self.ln(5)
            except Exception as e:
                self.body_text(f"[Could not load image: {e}]")

    def needs_new_page(self, min_space=60):
        """Check if we need a new page (less than min_space mm remaining)."""
        return self.get_y() > (self.h - self.b_margin - min_space)

    def maybe_add_page(self, min_space=60):
        """Add page only if needed."""
        if self.needs_new_page(min_space):
            self.add_page()


def load_findings(path):
    """Load findings from JSONL, filtering spam."""
    if not path.exists():
        return []
    findings = []
    seen_titles = set()
    with open(path) as f:
        for line in f:
            if line.strip():
                finding = json.loads(line)
                if not is_repetitive_finding(finding, seen_titles):
                    # Fix template variables
                    finding['description'] = fix_template_variables(
                        finding.get('description', ''),
                        finding.get('evidence', {})
                    )
                    findings.append(finding)
                    seen_titles.add(finding.get('title', ''))
    return findings


def deduplicate_findings(findings):
    """Remove duplicate/redundant findings."""
    seen_keys = set()
    unique = []
    for f in findings:
        # Create a key based on core content
        title = f.get('title', '')
        # Skip if we've seen very similar title
        title_key = re.sub(r'[^a-z0-9]', '', title.lower())[:50]
        if title_key in seen_keys:
            continue
        # Also check for duplicate evidence
        evidence = f.get('evidence', {})
        ev_key = str(sorted(evidence.items())[:3]) if evidence else ''
        full_key = f"{title_key}:{ev_key}"
        if full_key not in seen_keys:
            seen_keys.add(title_key)
            seen_keys.add(full_key)
            unique.append(f)
    return unique


def group_findings(findings):
    """Group findings by category."""
    mapping = {
        'metabolism': 'Energy Metabolism',
        'metabolic': 'Energy Metabolism',
        'energy': 'Energy Metabolism',
        'carbon_fixation': 'Energy Metabolism',
        'core_metabolism': 'Energy Metabolism',
        'defense': 'Defense Systems',
        'defense_systems': 'Defense Systems',
        'mobile_elements': 'Mobile Elements',
        'prophage': 'Mobile Elements',
        'adhesin': 'Cell Surface',
        'surface': 'Cell Surface',
        'surface_biology': 'Cell Surface',
        'cell_adhesion': 'Cell Surface',
        'giant_protein': 'Novel Features',
        'novel_cluster': 'Novel Features',
        'anomaly': 'Novel Features',
        'quantitative': 'Quantitative Analysis',
        'hypothesis_test': 'Quantitative Analysis',
        'statistical_finding': 'Quantitative Analysis',
        'comparative': 'Comparative Analysis',
        'outlier_genome': 'Comparative Analysis',
        'visualization': 'Visualizations',
        'synthesis': 'Synthesis',
        'narrative': 'Synthesis',
    }

    grouped = defaultdict(list)
    for f in findings:
        cat = f.get('category', 'Other')
        section = mapping.get(cat, 'Other')
        grouped[section].append(f)
    return grouped


def format_evidence_value(k, v):
    """Format a single evidence key-value pair."""
    if isinstance(v, (dict, list)):
        return None  # Skip complex structures
    # Truncate genome IDs
    if isinstance(v, str) and ('GCA_' in v or 'genomic' in v):
        v = truncate_genome_id(v)
    # Format numbers nicely
    if isinstance(v, float):
        if abs(v) < 0.001 or abs(v) > 10000:
            v = f"{v:.2e}"
        else:
            v = f"{v:.2f}"
    elif isinstance(v, int) and v > 1000:
        v = f"{v:,}"
    return f"{k.replace('_', ' ')}: {v}"


def render_synthesis_finding(pdf, finding):
    """Render synthesis findings with proper bullet formatting."""
    pdf.subsection_title(finding.get('title', 'Untitled'))

    desc = finding.get('description', '')
    # Check if description contains numbered points
    if re.search(r'\d+\.\s+[A-Z]+:', desc):
        # Parse numbered points - split on newlines or numbered patterns
        lines = desc.split('\n')
        intro_done = False
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # Check if it's a numbered point
            match = re.match(r'(\d+)\.\s+([A-Z]+):\s*(.*)', line)
            if match:
                intro_done = True
                num, header, content = match.groups()
                pdf.add_bullet(f"{header}: {content}")
            elif not intro_done:
                # It's the intro text
                pdf.body_text(line)
            else:
                # Continuation of previous point
                pdf.body_text(line)
    else:
        pdf.body_text(desc)


def generate_report():
    print("=" * 60)
    print("SURVEY REPORT GENERATOR")
    print("=" * 60)

    b = Sharur(DB_PATH)

    # Load and clean findings
    print(f"\nLoading findings from {FINDINGS_PATH}...")
    findings = load_findings(FINDINGS_PATH)
    findings = deduplicate_findings(findings)
    print(f"  Loaded {len(findings)} findings (after filtering)")

    grouped = group_findings(findings)

    # Get stats
    n_genomes = b.store.execute("SELECT COUNT(DISTINCT bin_id) FROM proteins")[0][0]
    n_proteins = b.store.execute("SELECT COUNT(*) FROM proteins")[0][0]
    high_priority = [f for f in findings if f.get('priority') == 'high']

    # Get figures
    figures = []
    if FIGURES_DIR.exists():
        figures = sorted(FIGURES_DIR.glob("*.png"), key=lambda x: x.stat().st_mtime, reverse=True)
    print(f"  Found {len(figures)} figures")

    pdf = SurveyReport()

    # Title page
    print("\nCreating title page...")
    pdf.add_page()
    # Decorative top bar (green theme)
    pdf.set_fill_color(60, 100, 60)
    pdf.rect(0, 0, pdf.w, 8, 'F')
    pdf.set_fill_color(90, 130, 90)
    pdf.rect(0, 8, pdf.w, 3, 'F')

    pdf.ln(50)
    pdf.set_font('Helvetica', 'B', 36)
    pdf.set_text_color(60, 100, 60)
    pdf.cell(0, 18, 'Altiarchaeota', 0, 1, 'C')
    pdf.set_font('Helvetica', '', 24)
    pdf.set_text_color(90, 130, 90)
    pdf.cell(0, 12, 'Survey Report', 0, 1, 'C')

    # Decorative line
    pdf.ln(10)
    pdf.set_draw_color(60, 100, 60)
    pdf.set_line_width(0.8)
    pdf.line(60, pdf.get_y(), pdf.w - 60, pdf.get_y())
    pdf.ln(15)

    pdf.set_text_color(60, 60, 60)
    pdf.set_font('Helvetica', '', 14)
    pdf.cell(0, 8, f'{n_genomes} genomes  |  {n_proteins:,} proteins  |  {len(findings)} findings', 0, 1, 'C')
    pdf.ln(8)
    pdf.set_font('Helvetica', 'I', 11)
    pdf.set_text_color(120, 120, 120)
    pdf.cell(0, 8, f'Generated: {datetime.now().strftime("%B %d, %Y")}', 0, 1, 'C')

    # Bottom decoration
    pdf.set_fill_color(60, 100, 60)
    pdf.rect(0, pdf.h - 8, pdf.w, 8, 'F')

    # Table of Contents (placeholder - will fill after)
    toc_page = pdf.page_no() + 1
    pdf.add_page()
    pdf.in_toc = True
    pdf.set_font('Helvetica', 'B', 20)
    pdf.set_text_color(60, 100, 60)
    pdf.cell(0, 12, 'Table of Contents', 0, 1, 'L')
    pdf.set_draw_color(60, 100, 60)
    pdf.set_line_width(0.5)
    pdf.line(pdf.l_margin, pdf.get_y(), pdf.l_margin + 60, pdf.get_y())
    pdf.set_text_color(0, 0, 0)
    pdf.ln(12)
    toc_y_start = pdf.get_y()
    pdf.in_toc = False

    # Executive summary
    print("Creating executive summary...")
    pdf.add_page()
    pdf.chapter_title(1, 'Executive Summary')

    n_annotated = b.store.execute("SELECT COUNT(DISTINCT protein_id) FROM annotations")[0][0]
    annot_rate = n_annotated / n_proteins * 100 if n_proteins else 0

    pdf.body_text(
        f"This report presents findings from systematic survey of {n_genomes} Altiarchaeota genomes "
        f"containing {n_proteins:,} proteins. {len(findings)} findings were logged, "
        f"with {len(high_priority)} classified as high priority."
    )

    pdf.section_title("Key Statistics")
    pdf.add_bullet(f"{n_genomes} metagenome-assembled genomes (MAGs)")
    pdf.add_bullet(f"{n_proteins:,} predicted proteins")
    pdf.add_bullet(f"{annot_rate:.1f}% annotation rate")

    # Top findings
    if high_priority:
        pdf.ln(5)
        pdf.section_title("Top Findings")
        for i, f in enumerate(high_priority[:5], 1):
            title = f.get('title', 'Untitled')[:80]
            pdf.add_bullet(f"{i}. {title}")

    # Predicate summary (dynamic)
    pdf.ln(5)
    pdf.section_title("Predicate Coverage")
    key_preds = ['hydrogenase', 'crispr_associated', 'adhesin', 'transposase', 'unannotated', 'giant']
    for pred in key_preds:
        count = b.store.execute(f"SELECT COUNT(DISTINCT protein_id) FROM protein_predicates WHERE '{pred}' = ANY(predicates)")[0][0]
        if count > 0:
            pdf.add_bullet(f"{pred}: {count:,} proteins")

    # Findings by section
    section_num = 2
    section_order = ['Quantitative Analysis', 'Comparative Analysis', 'Energy Metabolism',
                     'Defense Systems', 'Mobile Elements', 'Cell Surface', 'Novel Features',
                     'Visualizations', 'Synthesis', 'Other']

    for section_name in section_order:
        if section_name not in grouped:
            continue
        section_findings = grouped[section_name]
        n_findings = len(section_findings)

        print(f"  Section: {section_name} ({n_findings} findings)")

        # For sections with few findings, don't force new page
        if n_findings >= 3 or pdf.needs_new_page(80):
            pdf.add_page()
        else:
            pdf.ln(10)
            if pdf.needs_new_page(60):
                pdf.add_page()

        pdf.chapter_title(section_num, section_name)
        section_num += 1

        for finding in section_findings[:10]:
            # Check if we need new page before each finding
            pdf.maybe_add_page(40)

            # Special handling for synthesis
            if section_name == 'Synthesis':
                render_synthesis_finding(pdf, finding)
                continue

            pdf.subsection_title(finding.get('title', 'Untitled'))
            pdf.body_text(finding.get('description', ''))

            # Evidence - format nicely in a box
            evidence = finding.get('evidence', {})
            if evidence:
                ev_parts = []
                for k, v in list(evidence.items())[:5]:
                    formatted = format_evidence_value(k, v)
                    if formatted:
                        ev_parts.append(formatted)
                if ev_parts:
                    pdf.add_evidence_box("Evidence: " + ", ".join(ev_parts))

            pdf.add_separator()

    # Figures - separate analysis figures from neighborhood diagrams
    if figures:
        analysis_figs = [f for f in figures if 'neighborhood' not in f.stem]
        neighborhood_figs = [f for f in figures if 'neighborhood' in f.stem]

        if analysis_figs:
            print(f"  Adding {len(analysis_figs)} analysis figures...")
            pdf.add_page()
            pdf.chapter_title(section_num, 'Analysis Figures')
            section_num += 1

            # Figure descriptions
            fig_descriptions = {
                'genome_feature_heatmap': 'Distribution of key features across all genomes. Rows are genomes, columns are features.',
                'genome_size_vs_annotation': 'Relationship between genome size and annotation rate.',
                'protein_size_by_annotation': 'Protein size distributions for annotated vs unannotated proteins.',
                'defense_system': 'Distribution of defense systems (CRISPR, R-M, TA) across genomes.',
                'pathway_completeness': 'KEGG pathway completeness across the dataset.',
                'giant_protein': 'Size distribution of giant proteins (>1000aa).',
                'top_pfam': 'Most abundant Pfam domains in the dataset.',
            }

            for fig in analysis_figs[:12]:
                if pdf.get_y() > 200:
                    pdf.add_page()
                # Clean up figure name
                name = clean_figure_name(fig.stem)
                # Find matching description
                desc = ""
                for key, d in fig_descriptions.items():
                    if key in fig.stem:
                        desc = d
                        break
                pdf.section_title(name)
                if desc:
                    pdf.body_text(desc)
                pdf.add_image(str(fig), "")

        if neighborhood_figs:
            print(f"  Adding {len(neighborhood_figs)} neighborhood diagrams...")
            pdf.add_page()
            pdf.chapter_title(section_num, 'Genomic Neighborhoods')
            section_num += 1

            pdf.body_text(
                "Gene neighborhood diagrams showing genomic context around key loci. "
                "Arrows indicate gene direction, colors indicate functional categories."
            )

            for fig in neighborhood_figs[:8]:
                if pdf.get_y() > 200:
                    pdf.add_page()
                # Clean up neighborhood name - remove numeric prefixes
                name = clean_figure_name(fig.stem.replace('neighborhood_', ''))
                pdf.subsection_title(f"Neighborhood: {name}")
                pdf.add_image(str(fig), "")

    # Conclusion section
    print("  Adding conclusion...")
    pdf.add_page()
    pdf.chapter_title(section_num, 'Conclusion')
    section_num += 1

    # Generate dynamic conclusion
    high_count = len([f for f in findings if f.get('priority') == 'high'])
    medium_count = len([f for f in findings if f.get('priority') == 'medium'])

    pdf.body_text(
        f"This systematic survey of {n_genomes} Altiarchaeota genomes catalogued {len(findings)} findings "
        f"across multiple functional categories, with {high_count} high-priority and {medium_count} medium-priority observations."
    )

    # Summarize by section
    if grouped.get('Energy Metabolism'):
        pdf.body_text(
            "Energy metabolism analysis confirms the chemolithoautotrophic lifestyle with "
            "hydrogenases, carbon fixation pathways, and electron transport systems present across most genomes."
        )

    if grouped.get('Defense Systems'):
        pdf.body_text(
            "Defense system diversity includes CRISPR-Cas (multiple types), restriction-modification systems, "
            "and toxin-antitoxin modules, indicating active interactions with mobile genetic elements."
        )

    if grouped.get('Cell Surface') or grouped.get('Novel Features'):
        pdf.body_text(
            "Surface biology features including adhesins and giant proteins suggest specialization "
            "for attachment and potentially symbiotic interactions in their subsurface environment."
        )

    pdf.body_text(
        "This survey provides a foundation for targeted functional studies and comparative analyses "
        "with related archaeal lineages."
    )

    # Track final page count before going back for TOC
    total_pages = pdf.page_no()

    # Now go back and fill in TOC
    print("  Generating table of contents...")
    pdf.page = toc_page
    pdf.set_y(toc_y_start)
    pdf.in_toc = True
    for num, title, page in pdf.toc_entries:
        pdf.add_toc_entry(num, title, page)
    pdf.in_toc = False

    # IMPORTANT: Return to last page before saving
    pdf.page = total_pages

    # Save
    print(f"\nSaving to {OUTPUT_PDF}...")
    pdf.output(str(OUTPUT_PDF))

    print("\n" + "=" * 60)
    print("COMPLETE")
    print("=" * 60)
    print(f"  Output: {OUTPUT_PDF}")
    print(f"  Pages: {total_pages}")


if __name__ == "__main__":
    generate_report()
